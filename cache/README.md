# 缓存

从查数据库改成查缓存，能大幅度提升性能。当缓存不存在，如果降级成从数据库查询，在访问量大的时候，服务负载可能和直接查库差不多。
**尽量保证每个查询都能命中缓存,耗时和QPS才能稳定**

## 加载缓存
**redis不是可靠存储，重启或者服务器故障都可能导致数据丢失。** 为了防止中途失效，定时10分钟(其他也行)加载一次全量缓存，失效时间设置成定10分钟的3倍或者更多倍数。
就算定时任务少了几次没执行，后面恢复了也能把数据补上。

缓存时效性方面可以MQ保证。数据更新后发个消息，消费方从数据库加载数据，然后覆盖缓存，同时刷新缓存的失效时间。

## 使用缓存、不存在的数据

先从redis读，redis不存在时从数据库查，保证业务逻辑正确。缓存和数据库都不存在，爬虫或者恶意请求会频繁触发查redis和数据库。两次都是无效操作，还需要占用web服务的线程。
可以通过布隆过滤器(bloom filter)提前判断。具体实现可以查看代码的示例[RedisCacheController.java](src/main/java/io/github/onlyeat3/mybest/cache/RedisCacheController.java)
这张图可以让理解流程简单一点
[时序图](https://www.figma.com/file/c7zO1xI0Xx92aPTgHDBA5m/%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C-%E6%97%B6%E5%BA%8F%E5%9B%BE)

## 其他
- redis连接数对QPS的提升很大，建议设置最大连接数100以上
- 尽量保证redis操作的时间复杂度是O(1)
- 扩容也会有上限，超出上限部分的流量建议直接用限流器过滤掉

